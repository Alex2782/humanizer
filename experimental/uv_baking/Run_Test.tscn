[gd_scene load_steps=4 format=3 uid="uid://do3thyawu51hb"]

[ext_resource type="ArrayMesh" uid="uid://bcvg7he3mplkk" path="res://experimental/uv_baking/import_mesh.res" id="1_ja2se"]
[ext_resource type="ArrayMesh" uid="uid://ys1mnssck0qh" path="res://experimental/uv_baking/output_mesh.res" id="2_eytjn"]

[sub_resource type="GDScript" id="GDScript_vta3f"]
script/source = "extends Control

@onready var mesh :ArrayMesh = $InputMesh.mesh
var surfaces = []
var rect_packer : Naive_Row_Packer
var bin_size = pow(2,12)

func _ready():
	#print(pow(2,11))
	var rect_array = []
	for surface_id in mesh.get_surface_count():
		var sf_unwrapper = Surface_UV_Unwrapper.new(mesh,surface_id)
		surfaces.append(sf_unwrapper)
		sf_unwrapper.get_islands()
		#sf_unwrapper.get_island_bounding_boxes()
		for island_id in sf_unwrapper.island_boxes.size():
			var rect = sf_unwrapper.island_boxes[island_id]
			rect.size *= sf_unwrapper.get_albedo_texture_size()
			rect.position = Vector2.ZERO
			var packable_rect = Naive_Row_Packer.Packable_Rect.new(rect,surface_id,island_id)
			rect_array.append(packable_rect)
	rect_packer = Naive_Row_Packer.new(rect_array,bin_size)
	
	for packed_rect in rect_packer.rects:
		var surface = surfaces[packed_rect.surface_id]
		var old_island_position = surface.island_boxes[packed_rect.island_id].position
		var new_island_position = packed_rect.get_position() / bin_size
		var offset =  new_island_position - old_island_position
		var old_island_size = surface.island_boxes[packed_rect.island_id].size
		var new_island_size = packed_rect.get_size() / bin_size
		var island_scale = new_island_size/old_island_size
		#print(island_scale)
		var xform = Rect2(offset,island_scale)
		surface.island_transform[packed_rect.island_id] = xform
	
	var new_uv_image = Image.create(bin_size,bin_size,false,Image.FORMAT_RGBA8)
	
	for packed_rect in rect_packer.rects:
		var surface = surfaces[packed_rect.surface_id]
		##can output to texture rects and save from viewport
		#var texture_rect = TextureRect.new()
		#texture_rect.texture = AtlasTexture.new()
		#texture_rect.texture.atlas = surface.get_albedo_texture()
		#texture_rect.texture.region.size = packed_rect.get_size()
		#texture_rect.texture.region.position = surface.island_boxes[packed_rect.island_id].position * surface.get_albedo_texture_size()
		#texture_rect.position = packed_rect.get_position()
		#texture_rect.size = packed_rect.get_size()
		#add_child(texture_rect)	
	
	# or use the image copy functions, requires decompress which takes longer
		var old_texture_image : Image = surface.get_albedo_texture().get_image()
		old_texture_image.decompress()
		old_texture_image.convert(new_uv_image.get_format())
		#print(old_texture_image.get_format())
		var old_island_position = surface.island_boxes[packed_rect.island_id].position * surface.get_albedo_texture_size()
		var island_size =  packed_rect.get_size()
		var new_island_position = packed_rect.get_position()
		new_uv_image.blit_rect(old_texture_image,Rect2(old_island_position,island_size),new_island_position)
		
	new_uv_image.save_png(\"res://experimental/uv_baking/baked_uv.png\")
	
	combine_surfaces()
		
	# \"get_faces\" returns coordinates for all faces in all surfaces, this is not helpful
	#var faces = $Mesh.mesh.get_faces()
	#print(faces)

func combine_surfaces():
	var new_mesh = ArrayMesh.new()
	var new_sf_arrays = []
	new_sf_arrays.resize(Mesh.ARRAY_MAX)
	new_sf_arrays[Mesh.ARRAY_VERTEX] = PackedVector3Array()
	new_sf_arrays[Mesh.ARRAY_TANGENT] = PackedFloat32Array()
	new_sf_arrays[Mesh.ARRAY_NORMAL] = PackedVector3Array()
	new_sf_arrays[Mesh.ARRAY_INDEX] = PackedInt32Array()
	new_sf_arrays[Mesh.ARRAY_TEX_UV] = PackedVector2Array()
	
	var vertex_offset = 0
	for surface in surfaces:
		new_sf_arrays[Mesh.ARRAY_VERTEX].append_array(surface.surface_arrays[Mesh.ARRAY_VERTEX])
		new_sf_arrays[Mesh.ARRAY_TANGENT].append_array(surface.surface_arrays[Mesh.ARRAY_TANGENT])
		new_sf_arrays[Mesh.ARRAY_NORMAL].append_array(surface.surface_arrays[Mesh.ARRAY_NORMAL])
		for i in surface.surface_arrays[Mesh.ARRAY_INDEX]:
			i += vertex_offset
			new_sf_arrays[Mesh.ARRAY_INDEX].append(i)
		for vertex_id in surface.surface_arrays[Mesh.ARRAY_VERTEX].size():
			var uv = surface.surface_arrays[Mesh.ARRAY_TEX_UV][vertex_id]
			var island_id = surface.island_vertex[vertex_id]
			var island_xform = surface.island_transform[island_id]
			var new_uv = uv + island_xform.position
			
			var old_offset = surface.island_boxes[island_id].position - uv
			var new_offset = old_offset * island_xform.size
			#print(new_offset)
			new_uv += new_offset
			
			new_sf_arrays[Mesh.ARRAY_TEX_UV].append(new_uv)
		
		vertex_offset += surface.surface_arrays[Mesh.ARRAY_VERTEX].size()
		
	new_mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES,new_sf_arrays)
	
	var new_material = StandardMaterial3D.new()
	new_material.albedo_texture = load(\"res://experimental/uv_baking/baked_uv.png\")
	new_mesh.surface_set_material(0,new_material)
	ResourceSaver.save(new_mesh,\"res://experimental/uv_baking/output_mesh.res\")
	
		

"

[node name="test1" type="Control"]
layout_mode = 3
anchors_preset = 0
script = SubResource("GDScript_vta3f")

[node name="InputMesh" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0.608723, 0, 0)
mesh = ExtResource("1_ja2se")

[node name="Camera2D" type="Camera2D" parent="."]
position = Vector2(2263, 1559)
zoom = Vector2(0.25, 0.25)

[node name="OutputMesh" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, -0.704807, 0, 0)
mesh = ExtResource("2_eytjn")
